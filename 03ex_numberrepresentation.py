# -*- coding: utf-8 -*-
"""03ex_numberRepresentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GrCKdlwiQ8gU_Ac0x095FHHjjFVS2PnK
"""

from matplotlib.container import ErrorbarContainer

# Number 1: Number Representation Exercise

def ConvertNumberRep(num, newtype):
    
    if isinstance(num,float):
        raise ValueError('Converting floating point numbers is not possible with this function')
    else:
        if isinstance(num,str): 
            if num.startswith('0b'):
                oldtype = 'bin'
                try: 
                    num = int(num,2)
                except: 
                    raise ValueError('Input is not correct')
            elif num.startswith('0x'):
                oldtype = 'hex'
                try:
                    num = int(num, 16)
                except:
                    raise ('Input is not correct')
        else:
            oldtype = 'dec'
        
        if oldtype != newtype:
            if newtype == 'dec':
                return num
            elif newtype == 'bin':
                return bin(num)
            else:
                return hex(num)
        else:
            return num
            

a = bin(15)
b = 15
c = hex(15)

print('Bin To Int: ', a, str(b), ConvertNumberRep(a,'dec'))
print('Int To Bin: ',  str(b), a, ConvertNumberRep(b,'bin'))
print('Bin To Hex: ', a, c, ConvertNumberRep(a,'hex'))
print('Hex To Bin:', c, a, ConvertNumberRep(c,'bin'))
print('Int To Hex: ',b, c, ConvertNumberRep(b,'hex'))
print('Hex To Int: ', c, b, ConvertNumberRep(c, 'dec'))

#Number 2: 32-bit Floating Point Number Exercise 

def singleFloat(binstr):
    bias = 3500
    
    if int(binstr[0]) == 0: 
        s = +1
    else:
        s = -1
    
    exponent = binstr[1:9] 
    exponent = '0b'+str(exponent) 
    e = int(exponent,2)
    mantissa = binstr[9:32]  
    f = 1
    i = 1
    for m in mantissa:
        f += int(m)/(2**i)
        i += 1
    
    float_num = (s*f*(2**(e-bias)))
    return float_num

a = '00000011111000000000000000000000'
b = '11000000101100000000000000000000'
float_number = singleFloat(b)
print(float_number)

#Number 3: Underflow And Overflow Exercise 

underflow = 1.0
overflow = 1.0
up_limit = False
down_limit = False

while not up_limit:
    overflow_new = overflow*2
    if overflow_new == float('inf'):
        up_limit = True
    else:
        overflow = overflow_new

print('For floating point calculations, my computer overflows as follows: ', overflow)

while not down_limit:
    underflow_new = underflow/2
    if underflow_new == float(0.0):
        down_limit = True
    else:
        underflow = underflow_new

print('For floating point calculations, my computer underflows as follows: ', underflow)

def findOver ():
    overflow = 1.0
    up_limit = False
    while not up_limit:
        overflow_new = overflow*2
        if overflow_new == float('inf'):
            up_limit = True
        else:
            overflow = overflow_new
    return overflow

def findUnder ():
    underflow = 1.0
    down_limit = False
    while not down_limit:
        underflow_new = underflow/2
        if underflow_new == float(0.0):
            down_limit = True
        else:
            underflow = underflow_new
    return underflow

print(findOver())
print(findUnder())

#Number 4: Machine Precision Exercise 

d = 10.5
few = 0.001
precision = True

while precision:
    if d + few == d:
        precision = False
    else:
        few = few/10

print('As an example, the machine precision is as follows: ', few)

def Precision():
    d = 10.5
    few = 0.001
    precision = True
    
    while precision:
        if d + few == d:
            precision = False
        else:
            few = few/10
    
    return few

print(Precision())

#Number 5: Quadratic Solution Exercise

import math

def Solution_a(a,b,c):
    
    D = (b**2) - (4*a*c)
    if D < 0:
        print("The system does not have a solution")
        return
    elif D == 0:
        x = - b/(2*a)
        return x
    else:
        x1 = (- b - math.sqrt(D)) / (2*a)
        x2 = (- b + math.sqrt(D)) / (2*a)
        return x1, x2

a = 0.001
b = 1000
c = 0.001